# Dependency checking

In the generated program, say the r-th chunk, we add `sync_n` and `produce_n` before and after each command (suppose it is the n-th command in the sequence generated by shallow simulation).
`sync_n` commits dependent values and for each source i belonging the t-th chunk, it records the hash `h` of all dependent values generated by i-th command and used by n-th command into `depend_hashes[t]` as a tuple `(i, n, h)`.
`produce_n` records the hashes of dependent values produced by the n-th command. If the j-th command belonging to the t-th chunk depends on a set of values produced by the n-th command, it records the hash `h` of these values into `produce_hashes[t]` as a tuple `(n, j, h)`.

When the main part finishes, we need to establish connection between each pair of chunks, and do consistency check:
If r-th chunk uses t-th chunk's values, then sort r-th chunk's `depend_hashes[t]`, then merge their hashes into `h1`; Also, sort (may not be needed) t-th chunk's `produce_hashes[r]`, then merge their hashes into `h2`, compare `h1` and `h2`.

Note:
When recording hashes, we have to record the hash of each pair of commands, rather than merging the hash of the entire chunk on the fly.
Suppose given a program `c0; c1; c2; c3`, and it is partitioned into chunk A `c0;c1` and chunk B `c2;c3`. Then when executing chunk A, `produce_0` records the dependency between (0,2) and (0,3), `produce_1` records the dependency between (1,2) and (1,3). When executing chunk B, `sync_2` records the dependency between (0,2) and (1,2), `sync_3` records the dependency between (0,3) and (1,3).
* In chunk A, the ordering is: (0,2), (0,3), (1,2), (1,3);
* In chunk B, the ordering is: (0,2), (1,2), (0,3), (1,3).
They are different. So we have to store the hashes of each pair of commands, then sort them into (0,2), (0,3), (1,2), (1,3) before comparing.